<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script type="text/javascript">
      const A1 = { type: 'div', key: 'A1' };
      const B1 = { type: 'div', key: 'B1', return: A1 };
      const B2 = { type: 'div', key: 'B2', return: A1 };
      const C1 = { type: 'div', key: 'C1', return: B1 };
      const C2 = { type: 'div', key: 'C2', return: B1 };
      const C3 = { type: 'div', key: 'C3', return: B2 };
      const C4 = { type: 'div', key: 'C4', return: B2 };

      A1.child = B1;
      B1.sibling = B2;
      B1.child = C1;
      C1.sibling = C2;
      B2.child = C3;
      C3.sibling = C4;

      console.log(A1);

      const startWork = Fiber => {
        console.log(`${Fiber.key}开始`);
      };
      const endWork = Fiber => {
        console.log(`${Fiber.key}结束`);
      };

      const foo = Fiber => {
        startWork(Fiber);
        if (Fiber.child) {
          return Fiber.child;
        }
        // while (Fiber) {}
      };
      const loopMain = nextUnitOfWork => {
        while (nextUnitOfWork) {
          nextUnitOfWork = foo(nextUnitOfWork);
        }
        if (!nextUnitOfWork) {
          console.log('流程结束');
        }
      };

      loopMain(A1);
      function SubType() {
        this.name = 'subtype';
      }
      SubType.prototype.getName = function() {
        return this.name;
      };
      function pp() {}
      pp.prototype = new SubType();
      // pp.prototype.constructor = pp;
      const A = new pp();
      function dabao() {}
      dabao.prototype = new pp();
      const B = new dabao();
      console.log(B.getName());
      console.log(B);
      console.log(A);

      function baba() {
        this.name = 'baba';
      }
      baba.prototype.fnn = function() {
        return this.name;
      };
      const eee = new baba();
      console.log(eee.fnn());

      class father {
        static max = 2;
        constructor() {
          this.name = '大宝';
        }
        fn() {
          return this.name;
        }
      }
      father.prototype.fn1 = function() {
        return this.name;
      };

      class son extends father {
        constructor() {
          super();
          this.age = 8;
        }
      }
      const a = new son();
      console.log(a.fn1());
      // 深拷贝：对对象内部进行深拷贝，支持 Array、Date、RegExp、DOM
      const deepCopy = sourceObj => {
        // 如果不是对象则退出（可停止递归）
        if (typeof sourceObj !== 'object') return;

        // 深拷贝初始值：对象/数组
        let newObj = sourceObj instanceof Array ? [] : {};

        // 使用 for-in 循环对象属性（包括原型链上的属性）
        for (let key in sourceObj) {
          // 只访问对象自身属性
          if (sourceObj.hasOwnProperty(key)) {
            // 当前属性还未存在于新对象中时
            if (!(key in newObj)) {
              if (sourceObj[key] instanceof Date) {
                // 判断日期类型
                newObj[key] = new Date(sourceObj[key].getTime());
              } else if (sourceObj[key] instanceof RegExp) {
                // 判断正则类型
                newObj[key] = new RegExp(sourceObj[key]);
              } else if (typeof sourceObj[key] === 'object' && sourceObj[key].nodeType === 1) {
                // 判断 DOM 元素节点
                let domEle = document.getElementsByTagName(sourceObj[key].nodeName)[0];
                newObj[key] = domEle.cloneNode(true);
              } else {
                // 当元素属于对象（排除 Date、RegExp、DOM）类型时递归拷贝
                newObj[key] = typeof sourceObj[key] === 'object' ? deepCopy(sourceObj[key]) : sourceObj[key];
              }
            }
          }
        }

        return newObj;
      };

      // deepCopy 函数测试效果
      const objA = {
        name: 'jack',
        birthday: new Date(),
        pattern: /jack/g,
        body: document.body,
        others: [123, 'coding', new Date(), /abc/gim],
      };
      const tabalB = JSON.parse(JSON.stringify(objA));
      console.log(objA === tabalB);
      console.log(objA.others === tabalB.others);
      console.log(objA, tabalB);
      const objB = deepCopy(objA);
      console.log(objA === objB); // false
      console.log(objA.others === objB.others); // false
      console.log(objA, objB); // 对象内容一样

      const objC = {
        type: 'div',
        key: 'objC',
      };
      const methodsList = [
        a => {
          console.log(a);
        },
        (a, b) => {
          return console.log(a + b);
        },
        (f = (...adds) => {
          if (adds.length === 0) return 0;
          if (adds instanceof Array && adds.length > 1) {
            return adds.shift() + adds.shift() + f(...adds);
          } else {
            return adds.shift();
          }
        }),
      ];
      console.log(methodsList[2](1, 3, 3, 3, 4));
    </script>
  </body>
</html>
